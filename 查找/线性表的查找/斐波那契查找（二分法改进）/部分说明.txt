if (key < arr[mid]) {
            //我们应该继续向数组的前面查找（左边）
            high = mid - 1;
            //1.全部元素 = 前面的元素 + 后面的元素
            //2.f[k] = f[k-1] + f[k-2]
            //因为前面 f[k-1]个元素，所以可以继续拆分f[k-1] = f[k-2]+f[k-3]
            //即下次循环mid = f[k-1-1] -1
            k--;
        } else if (key > arr[mid]) {
            //我们应该继续向数组的后面查找(右边)
            low = mid + 1;
            //1.全部元素 = 前面的元素 + 后面的元素
            //2.f[k] = f[k-1] + f[k-2]
            //3，因为后面我们有f[k-2]，所以可以继续拆分 f[k-2] = f[k-3]+f[k-4]
            //4.即在f[k-2]的前面进行查找 k-=2
            //5.即下次循环mid = f[k-1-2] -1
            k -= 2;

这里主要是说明下一次循环的时候，可以将前面（key < arr[mid]）的时候将前面的斐波那契数的数组再做为
一个整体进行拆分，求出mid值再进行比较
如果是后面（key > arr[mid]）也是一样将后面那部分斐波那契数的数组进行再次拆分，使得能再进行找出mid值进行比较


一开始的时候确定数组的长度，然后再斐波那契数列中找出一个比数组长度大一点的数作为新的数组长度，这时候多余的空内存放入数组的
最大元素值，就构成数组。

至于代码中当所查找值小于中间值的时候k--，是因为拆分以后f[k-1] = f[k-2]+f[k-3]，mid=low+f[k-1-1] -1，相当于是
拆分后的前半部分
后半部分k-2原因是后半部分为f[k-2] = f[k-3]+f[k-4]，求mid时候取前半部分

重新进入循环的时候就可以直接取到mid值