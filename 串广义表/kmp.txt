kmp的核心主要是
模块串中每次重新回到的位置，，也就是所要求的next数组的值
kmp主要是将bf算法中重复判断的步骤省略，直接可以找到没有重复的位置然后进行判断
https://www.bilibili.com/video/BV1jb411V78H?from=search&seid=5864175149701197511&spm_id_from=333.337.0.0
将kmp算法原理可以讲的很清楚的老师
每次移动的步数就等于前缀的长度减去有部分重复的个数   其中重复 的个数应该小于前缀的个数
http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html
从根本上讲出kmp算法的老师


next数组代码
用图解法讲
https://www.bilibili.com/video/BV16X4y137qw?from=search&seid=14444922586439895845&spm_id_from=333.337.0.0

个人理解：
在next数组代码中
在连续判断相同的时候该代码
可以将下一个位置直接定位到上一次判断的两个相同串的后面一个位置
比方说1和5相同下一次就判断2和6再下一次3和7前提是串是相同的a和a相同
abcxabc

next[j]求法就是当前所处的位置的前缀相同的串的个数+1
模式串的最后一位字符不会影响next数组的结果因为看的只是当前位置的前缀字符中部分相同的个数



next【j+1】最大值为next[j]+1就是比方16位你前面那个15next为3然后最好的情况
你判断的是各自下一个串是否相同，最多只能加1

int GetNext(char ch[],int length,int next[]){//length为串ch的长度
    next[1]=0;
    int i=1,j=0;//i当前主串正在匹配的字符位置，也是next数组的索引
     while(i<=length){
         if(j==0||ch[i]==ch[j])
         {++i;++j;next[i]=j;}////next[++i]=++j;
         else j=next[j];}}
  
假设要求的是i=17，j未知，假设i=16的next为8的话就相当于
在第17位以前 有7个前缀和7个后缀是相同的，，就是1-7和9-16完全一样

最好的情况是第8个和第17个相同，此时1-8和9-17是完全相同的所以第17的next的值就为9

其次好的情况是  进行 对第8个之前的进行分解第8个他的next为4的话说明1-3和5-7是完全相同
这里已经判断好在1-7中的情况，而我们考虑的是紧靠17的后缀，而1-7和9-16完全相同
所以对撑过去就相当于考虑1-3和14-16他们两个完全相同，然后再判断4号和17号是否相同
相同的话则next值为5否则就继续判断



